---
layout: post
title:  "Domain Driven Design"
date:   2019-12-12 09:39:37 +0300
description: "
If you ask five different developers what they understand by domain driven design, you are most likely going to get five different answers. To make matters slightly worse and even if they did one did thoroughly read Eric Evan's book, it's not readily apparent how one would go about extracting a canonical definition. Virtually everybody working in the field of software development agrees that properly architecting an application is extremely important -- just like a poorly constructed building, a software project lacking a solid architectural background can easily come crashing down after a while. 
"
icon: "domain-icon.jpg"
categories:
---
While the term *domain driven design* gets thrown around quite a bit, if you ask five different developers what they understand by DDD, you are most likely going to get five different answers and to make matters slightly worse even Eric Evan's book which is the canonical authority on all things DDD doesn't give an exact definition.

While it goes without saying that a thorough understanding of the business should be important for all parties involved (developers, product owners, designers), sometimes there's a slight disconnect between the imediate goals of the people involved.

* The company must make a profit so it needs to solve certain business needs for existing and potential customers.
* Developers usually earn a salary, don't particularly like meetings and would like to work with new and exciting technologies.
* Designers are highly creative and would like to showcase their skills.

At its core, DDD is a recipe (or codified prescription) for doing software development that attempts to bridge this disconnect. 

![image-title-here](/images/ddd.webp){:class="img-responsive"}

One way to think about DDD is that it is a top-down way of looking at the development process, in the sense that we define and codify the business requirements first and then we build on top of that. 

Let us imagine the following scenario: the team is tasked with creating creating a simple e-commerce site that sales sporting apparel. DDD mandates that before we choose what technology we build the application in, whether we choose a microservice approach and before we design the UX and UI, we define the exact business objects and processes. We know our application will have to have user accounts and these users need to be able to set their log on information, define billing details, one or more address and so forth. We also need to define what products we sell in our catalogue, product categories so we are able to offer the users a nice faceted search functionality and we need to keep track how many products we have in stock.

The product owner of course has all this information but it has to be communicated effectively to the development team. Enter Event Storming. The brainchild of Alberto Brandolini, it's essentially a way for the team members to communicate ideas using sticky notes and a whiteboard.

![event-storming](/images/storming.jpg){:class="img-responsive"}

Virtually all team members of a software development team agree that properly architecting an application is extremely important -- because just like a poorly constructed building, a software project lacking a solid architectural background can easily come crashing down after a while. But unlike with buildings, because of software's fluid development nature there's always the feeling that one can build functionality poorly initially (say to meet a deadline) and then go back and change things. The problem with this line of thinking is if new functionality is built on top of existing one, this never ends up happening, so constructing a solid foundation is extremely important. 

## What DDD isn't
When ORMs entered the scene, they put the concept of a model or entity at the forefront. All of a sudden developers didn't really have to concern themselves with low level database queries, join tables in case of many-to-many relations etc. We could just focus on defining the objects and the levels between them and the library would take care of the rest. All this might sound quite familiar and in effect what we've described is a model driven architecture approach.  While DDD certainly is compatible with this approach, there is a bit more to it and we'll get into it shortly.

<pre><code>class Customer
{
  public Id { get; set; }
  public FullName { get; set; }
  public Address { get; set; }
} 
</code></pre>

Of course, a domain expert isn't interested things like databases (SQL vs NoSQL), comunication protocols like REST or gRPC and so forth. Domain experts aren't interested necesarily in UX either, all these things come afterwards. These things pertain to *how* the business goal is achieved not to *what* the business goal is.

What we described goes by the term [Model Driven Architecture](https://en.wikipedia.org/wiki/Model-driven_architecture). Domain Driven Design counts as MDA but not viceversa because DDD is more strict.

<!-- While a PO will most certainly not write any code, he or she can definitely define something like this in enterprise architect.  -->

## Enter DDD
Domain modeling mandates that the software team defines the *what* first. DDD is actually a bit more prescriptive when it comes to doing things and it introduces more concepts such as:

* Entity (what we just discussed)
* Aggregate (a group of entities that can be treaded as a standalone enitity)
* Service
* Bounded context
* Domain events

Quite often, developers have a very poor understanding of how the or user or customers are actually using the application and sometimes even UX designers have trouble with it because users might not necessarily conform to the clearly thought out scenarios that they've planned beforehand. Customer support definitely has that understanding and ideally so should the product owner. 

When your domain gets really complicated, it's really worth for you to isolate it in individual islands. It makes it much easier to manage complexity.

![bounded-contexts](/images/bounded.png){:class="img-responsive"}

*Bounded make for good candidates for individual microservices but they don't have to be. Remember, we are using DDD to inform our technical decisions, not the other way around.*

While a lack of technical or programing skills can be a problem in some cases, communication issues are much more prevalent in software projects -- words mean different things to different people, and it all depends on the context so at the core of DDD lies a concept ccalled *ubiquitous language*. I'd like to argue that DDD as a methodology pushes this approach. Which is where ubiquitous language comes into play.

You can do event storming outside the context of DDD but if you aren't doing event storming, you are probably not doing DDD bby the book. Obviously, the goal is before the developers decide the technology stack, the approach etc. they know what exactly they are going to acomplish (the fact that they have to stand up while doing it also forces them to expedite matters).

Event storming is intended to create and share a common understanding of the domain model. It's not a replacement for a design document, flow chart, UML diagram, deployment plan, architecture diagram, or anything else related to implementation.

The first step is to find the domain events and write them on orange sticky notes. When all domain events are found the second step is to find for each domain event the command that caused it. Commands are written on blue notes and placed directly before the corresponding domain event. In the third step the aggregates are identified on which the commands are executed and to which happen the domain events. The aggregates are written in yellow stickies.

