<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Achieving High Scalability With CQRS</title>
  <meta name="description" content="CQRS stands for Command Query Responsibility Segregation, and the main idea behind it is that we want to separate the reading part of the pipeline from the w...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/jekyll/update/2017/06/13/cqrs.html">
  <link rel="alternate" type="application/rss+xml" title="achiral" href="/feed.xml">
  <link href="https://fonts.googleapis.com/css?family=Playfair+Display|Roboto:200,300,400" rel="stylesheet">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    <svg class="site-logo" width="35" height="35" viewBox="0 0 100 100" stroke="#bbb" stroke-width="2.5" fill="#222" xmlns="http://www.w3.org/2000/svg">
      <rect width="400" height="400" fill="#222" stroke-width="0"></rect>
      <line x1="50" y1="40" x2="20" y2="35" />
      <line x1="50" y1="40" x2="80" y2="35" />
      <line x1="50" y1="40" x2="50" y2="75" />
      <line x1="50" y1="40" x2="30" y2="60" />
      <line x1="50" y1="40" x2="70" y2="60" />
      <circle cx="50" cy="40" r="9" />
      <circle cx="20" cy="35" r="9" />
      <circle cx="80" cy="35" r="9" />
      <circle cx="25" cy="62" r="9" />
      <circle cx="75" cy="62" r="9" />
      <circle cx="50" cy="75" r="9" />
    </svg>

     

    <a class="site-title" href="/">achiral</a> 
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

      <div class="trigger">
          
        <a class="page-link" href="/about/">About</a>           
      </div>
    </nav>
    
  </div>
</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <br/>
  <br/>
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Achieving High Scalability With CQRS</h1>   

    <p class="post-meta">
      <time datetime="2017-06-13T06:39:37+03:00" itemprop="datePublished">
        
        Jun 13, 2017
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>CQRS stands for Command Query Responsibility Segregation, and the main idea behind it is that we want to separate the reading part of the pipeline from the writing part. With CQRS, a method either does writes, or reads, but never both — or to put it more simply, a method that returns a result should never change that result.</p>

<p>Architecturally, it looks something like this:</p>

<p><img src="/images/cqrs.png" alt="image-title-here" class="img-responsive" /></p>

<p>What would be the advantage of separating the read and write path0s? Well, for starters, in most applications, the number of read operations performed is orders of magnitude bigger than the number of write operations. Imagine your typical Facebook type app. As a user, how often do you browse other people’s profiles, and how often do you actually post on your own page?</p>

<p>So obviously, for an application like that we need an architecture that scales out easily — namely it should be easy to host our web application on multiple servers. The stateless nature of the web helps in that respect, but what is really problematic is the fact that we have to track state — and we have to do it for multiple users. So let’s look at a way of doing that.
Obviously, if you are writing and updating data using the same model, it’s pretty hard to do any read related optimizations, because you will always be transferring the whole object over the wire when you are doing CRUD. There is of course the possibility of doing projections in the GET methods of your API, but this involves doing expensive inner joins on your relational database, then projecting the result of that query to some kind of view model (usually doing some kind of mapping). These can be very expensive operations, especially if your database is partitioned across multiple servers.</p>

<h2 id="achieving-scalability">Achieving scalability</h2>

<p>A typical distributed application works like the one in the picture. A user will make a request to a public endpoint, and based on the load of each server in the network, it will redirect the request to one server in the list. This way, as the number of users for our application increases, we can simply add additional servers to our server farm.
The problem with the following picture is keeping track of data.</p>

<p>We can do two things:</p>
<ol>
  <li>Connect all application servers to a single database server</li>
  <li>We can have each application have it’s own server</li>
</ol>

<p>But the problem in case number 1. is that the database server quickly becomes a bottleneck, and in case number 2. we might have a be redirected to server B when he/she writes something, and then when reading that data, a user would be redirected to server A. To solve this, there are two strategies that can be used, and they can be used together. Affinity and replication.
Replication means that we use approach number 2. and we pretty much duplicate data on all servers. Affinity means that we redirect traffic for a specific user to a specific server instance. User “X” will write to server A, user “Y” to server B etc. This means that we also need to have a more intelligent load balancer in place.
Also, an issue with the affinity strategy is: what do you do if a user needs to get data from multiple users — let’s say rendering the wall in Facebook. The users might have their data on multiple servers.</p>

<h2 id="cqrs-to-the-rescue">CQRS to the rescue</h2>

<p>An application the size of Facebook probably has hundreds of thousands of servers and sophisticated proprietary caching and data storage. But it is a good example of the problems that can arise when scaling out web applications. We also don’t want to replicate all the data on all database server because it really becomes huge. So we usually use a combination of the techniques — for a very big application we would replicate data across data centers for speed and consistency, and we also use some for of affinity.</p>

<p>Let’s get back to the Facebook wall example. Imagine that we need to aggregate data from 30 different Facebook friends. Because we used write affinity, their posts might be on different servers, so aggregating the whole wall would be quite time consuming. Jill from the US might post something, my colleagues from the Netherlands might post something else, so it’s very unlikely the data will end up on the same database server.</p>

<p>Decoupling reading and writing allows us to have both read and write affinity. The read database in the architectural diagram acts as a view cache.
With CQRS, posting something on your wall will write it into the primary (write) database(s), and this will send notification events to everybody that’s interested in that. So let’s say my user is configured to always have read affinity with server X. That server will be notified by the servers which host the write part of the application queue, and it will update it’s local cache. Also, not only does the read part have different user affinity than the write part, the models are usually denormalized for speed of access.</p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            <b>
              achiral
            </b>
          </li>
          <li>
            Intrarea Doinei 5
          </li>
          
          <li><a href="mailto:office@achiral.com">office@achiral.com</a></li>
          
          <li>
            +40 732 591 103
          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p style="margin-top:10px">
          <b>achiral</b> offers consulting and custom software development services on the node.js, Ruby on Rails and .NET stacks. 
        </p>
      </div>
    </div>
  </div>
</footer>

  </body>

</html>
