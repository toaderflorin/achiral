<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Tail Call Optimizations In F#</title>
  <meta name="description" content="I chose F# for this article because that’s the functional language I have most experience in, but the same concepts can be applied to any language, even Java...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/jekyll/update/2016/06/13/tail-calls-fsharp.html">
  <link rel="alternate" type="application/rss+xml" title="achiral" href="/feed.xml">
  <link href="https://fonts.googleapis.com/css?family=Playfair+Display|Roboto:200,300,400" rel="stylesheet">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    <svg class="site-logo" width="35" height="35" viewBox="0 0 100 100" stroke="#bbb" stroke-width="2.5" fill="#222" xmlns="http://www.w3.org/2000/svg">
      <rect width="400" height="400" fill="#222" stroke-width="0"></rect>
      <line x1="50" y1="40" x2="20" y2="35" />
      <line x1="50" y1="40" x2="80" y2="35" />
      <line x1="50" y1="40" x2="50" y2="75" />
      <line x1="50" y1="40" x2="30" y2="60" />
      <line x1="50" y1="40" x2="70" y2="60" />
      <circle cx="50" cy="40" r="9" />
      <circle cx="20" cy="35" r="9" />
      <circle cx="80" cy="35" r="9" />
      <circle cx="25" cy="62" r="9" />
      <circle cx="75" cy="62" r="9" />
      <circle cx="50" cy="75" r="9" />
    </svg>

     

    <a class="site-title" href="/">achiral</a> 
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

      <div class="trigger">
          
        <a class="page-link" href="/about/">About</a>           
      </div>
    </nav>
    
  </div>
</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <br/>
  <br/>
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Tail Call Optimizations In F#</h1>   

    <p class="post-meta">
      <time datetime="2016-06-13T06:39:37+03:00" itemprop="datePublished">
        
        Jun 13, 2016
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I chose F# for this article because that’s the functional language I have most experience in, but the same concepts can be applied 
to any language, even JavaScript.</p>

<p><img src="/images/fsharp.png" alt="image-title-here" class="img-responsive" /></p>

<p>Let’s take a simple piece of code in F# that calculates the sum of a large sequence. And let’s say this sequence is being 
evaluated on the fly, so we don’t know how long it is (but it can be very long). A sequence is just the equivalent of an 
Enumerable and that’s how it’s actually implemented under the hood in the CLR, so it can even be infinite — but if it’s 
infinite, obviously summation will fail. The reason why I am using a sequence instead of a list is because a lot of the time 
in F# we abstract the data reading part of a process in the form of an IEnumerable that yields data, similar to C#. 
Now obviously when dealing with sequences, there are a lot of prebuilt functions — so you won’t need to implement a Sum() function, 
but let’s say we want to implement our own for the sake of argument.</p>

<p>A lot of the stuff that we are doing in F# is based on functions which are recursive, because pure functional programming is 
stateless (so no iterating blocks that update a state variable). So it will look like this:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">mySequence</span> <span class="o">=</span> <span class="nx">seq</span> <span class="p">{</span> <span class="mi">1</span><span class="p">..</span><span class="mi">1000</span> <span class="p">}</span> 
<span class="kd">let</span> <span class="nx">rec</span> <span class="nx">seqSum</span> <span class="nx">sequence</span> <span class="o">=</span> 
  <span class="k">if</span> <span class="nx">Seq</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="nx">sequence</span> <span class="nx">then</span> <span class="mi">0</span> 
  <span class="k">else</span> <span class="nx">Seq</span><span class="p">.</span><span class="nx">head</span> <span class="o">+</span> <span class="nx">seqSum</span> <span class="p">(</span><span class="nx">Seq</span><span class="p">.</span><span class="nx">skip</span> <span class="mi">1</span> <span class="nx">sequence</span><span class="p">)</span>
<span class="nx">printf</span> <span class="s2">"The sum of the sequence is %d:"</span> <span class="p">(</span><span class="nx">seqSum</span> <span class="nx">mySequence</span><span class="p">)</span></code></pre></figure>

<p>But what happens if our collection is so big, that the code will throw a stack overflow exception?</p>

<p><strong>Enter Tail Call Optimizations</strong></p>

<p>It turns out that if the recursive call is the last instruction in the method, the F# compiler is smart enough to replace 
recursive calls with sequential goto calls, because there’s nothing to do afterwards (hence, no need to save a stack-frame 
with the current execution state on the stack). So let’s revisit the code we wrote and explain why it isn’t tail optimized. 
We are going to break the last instruction into separate instructions like so:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">let</span> <span class="n">mySequence</span> <span class="p">=</span> <span class="n">seq</span> <span class="p">{</span> <span class="m">1.</span><span class="p">.</span><span class="m">1000</span> <span class="p">}</span> 
<span class="k">let</span> <span class="n">rec</span> <span class="n">seqSum</span> <span class="n">sequence</span> <span class="p">=</span> 
  <span class="k">if</span> <span class="n">Seq</span><span class="p">.</span><span class="n">isEmpty</span> <span class="n">sequence</span> <span class="n">then</span> 
    <span class="m">0</span> 
  <span class="k">else</span> 
    <span class="k">let</span> <span class="n">recursiveSum</span> <span class="p">=</span> <span class="nf">seqSum</span> <span class="p">(</span><span class="n">Seq</span><span class="p">.</span><span class="n">skip</span> <span class="m">1</span> <span class="n">sequence</span><span class="p">)</span> 
    <span class="n">Seq</span><span class="p">.</span><span class="n">head</span> <span class="n">sequence</span> <span class="p">+</span> <span class="n">recursiveSum</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">seqSum</span> <span class="n">mySequence</span>
<span class="n">printf</span> <span class="s">"The sum of the sequence is %d:"</span> <span class="n">sum</span></code></pre></figure>

<p>You can clearly see that the recursive call isn’t the last instruction in the method, so the compiler won’t be able to do the 
optimization we just talked about. Maybe there is a way to rewrite our code so that we can actually achieve this purpose. There 
actually is. We are going to use accumulators.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">let</span> <span class="n">mySequence</span> <span class="p">=</span> <span class="n">seq</span> <span class="p">{</span> <span class="m">1.</span><span class="p">.</span><span class="m">1000</span> <span class="p">}</span> 
<span class="k">let</span> <span class="n">rec</span> <span class="n">seqSum</span> <span class="n">sequence</span> <span class="n">acc</span><span class="p">:</span><span class="kt">int</span> <span class="p">=</span> 
  <span class="k">if</span> <span class="n">Seq</span><span class="p">.</span><span class="n">isEmpty</span> <span class="n">sequence</span> <span class="n">then</span> 
    <span class="n">acc</span> 
  <span class="k">else</span> 
    <span class="nf">seqSum</span> <span class="p">(</span><span class="n">Seq</span><span class="p">.</span><span class="n">skip</span> <span class="m">1</span> <span class="n">sequence</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="p">+</span> <span class="n">Seq</span><span class="p">.</span><span class="n">head</span> <span class="n">sequence</span><span class="p">)</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">seqSum</span> <span class="n">mySequence</span> <span class="m">0</span>
<span class="n">printf</span> <span class="s">"The sum of the sequence is %d:"</span> <span class="n">sum</span></code></pre></figure>

<p>This is tail optimized because we can write it like this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">let</span> <span class="n">mySequence</span> <span class="p">=</span> <span class="n">seq</span> <span class="p">{</span> <span class="m">1.</span><span class="p">.</span><span class="m">1000</span> <span class="p">}</span> 
<span class="k">let</span> <span class="n">rec</span> <span class="n">seqSum</span> <span class="n">sequence</span> <span class="n">acc</span><span class="p">:</span><span class="kt">int</span> <span class="p">=</span> 
  <span class="k">if</span> <span class="n">Seq</span><span class="p">.</span><span class="n">isEmpty</span> <span class="n">sequence</span> <span class="n">then</span> 
    <span class="n">acc</span> 
  <span class="k">else</span> 
    <span class="k">let</span> <span class="n">remainingSequence</span> <span class="p">=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">skip</span> <span class="m">1</span> <span class="n">sequence</span> 
    <span class="k">let</span> <span class="n">newAccValue</span> <span class="p">=</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">Seq</span><span class="p">.</span><span class="n">head</span> <span class="n">sequence</span> 
    <span class="n">seqSum</span> <span class="n">remainingSequence</span> <span class="n">newAccValue</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">seqSum</span> <span class="n">mySequence</span> <span class="m">0</span> 
<span class="n">printf</span> <span class="s">"The sum of the sequence is %d:"</span> <span class="n">sum</span></code></pre></figure>

<p>So what we are doing is simply adding the sum in a local value which we are passing along recursively. This is as close a thing to 
state we have in purely functional programming. The problem with this code is that it is not very nice, because we need to initialize 
it with the starting value for the accumulator. A nice feature of functional programming is that we can create nested functions like so:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">let</span> <span class="n">mySequence</span> <span class="p">=</span> <span class="n">seq</span> <span class="p">{</span> <span class="m">1.</span><span class="p">.</span><span class="m">1000</span> <span class="p">}</span> 
<span class="k">let</span> <span class="n">seqSum</span> <span class="n">sequence</span> <span class="p">=</span> 
  <span class="k">let</span> <span class="n">rec</span> <span class="n">seqSumInternal</span> <span class="n">sequenceInternal</span> <span class="n">acc</span> <span class="p">=</span> 
    <span class="k">if</span> <span class="n">Seq</span><span class="p">.</span><span class="n">isEmpty</span> <span class="n">sequenceInternal</span> <span class="n">then</span> 
      <span class="n">acc</span> 
    <span class="k">else</span> 
      <span class="k">let</span> <span class="n">remainingSequence</span> <span class="p">=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">skip</span> <span class="m">1</span> <span class="n">sequenceInternal</span> 
      <span class="k">let</span> <span class="n">newAccValue</span> <span class="p">=</span> <span class="n">acc</span> <span class="p">+</span> <span class="n">Seq</span><span class="p">.</span><span class="n">head</span> 
      <span class="n">sequenceInternal</span> 
        <span class="n">seqSumInternal</span> <span class="n">remainingSequence</span> <span class="n">newAccValue</span> <span class="n">seqSumUtil</span> <span class="n">sequence</span> <span class="m">0</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="nf">seqSum</span> <span class="p">(</span><span class="n">mySequence</span><span class="p">)</span> 
<span class="n">printf</span> <span class="s">"The sum of the sequence is %d:"</span> <span class="n">sum</span></code></pre></figure>

<p>We just encapsulated our “ugly” function inside a “nice” one and we are exposing a proper signature. Our internal function is 
also nicely recursion tail optimized. This is how all the default F# functions are implemented so you can be sure that when you 
are using them, they will not blow up your stack. A word of causing for those looking to implement a functional programming style 
in C#: Tail optimization doesn’t always work. The JIT will produce optimized code for .NET applications running on 64 bit machines 
with “Platform target: Any CPU” or for a 64 bit target. Any other combination will result in unoptimized code.</p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            <b>
              achiral
            </b>
          </li>
          <li>
            Intrarea Doinei 5
          </li>
          
          <li><a href="mailto:office@achiral.com">office@achiral.com</a></li>
          
          <li>
            +40 732 591 103
          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p style="margin-top:10px">
          <b>achiral</b> offers consulting and custom software development services on the node.js, Ruby on Rails and .NET stacks. 
        </p>
      </div>
    </div>
  </div>
</footer>

  </body>

</html>
